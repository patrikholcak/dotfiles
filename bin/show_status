#!/usr/bin/env python2.7

# @desc     Tired of having to go into each sub dir to find out whether or
#           not you did a git commit? Tire no more, just use this!
#
# @author   Mike Pearce <mike@mikepearce.net>
# @since    18/05/2010

# Grab some libraries
import sys
import os
import glob
import commands
from optparse import OptionParser

# Setup some stuff
dirname = './'
gitted  = False
mini    = True

class BColors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'

    def disable(self):
        self.HEADER = ''
        self.OKBLUE = ''
        self.OKGREEN = ''
        self.WARNING = ''
        self.FAIL = ''
        self.ENDC = ''

parser = OptionParser(description="\
Show Status is awesome. If you tell it a directory to look in, it'll scan \
through all the sub dirs looking for a .git directory. When it finds one \
it'll look to see if there are any changes and let you know. \
It can also push and pull to/from a remote location (like github.com) \
(but only if there are no changes.) \
Contact mike@mikepearce.net for any support.")
parser.add_option("-d", "--dir",
                    dest    = "dirname",
                    action  = "store",
                    help    = "The directory to parse sub dirs from",
                    default = os.path.abspath("./")+"/"
                    )

parser.add_option("-v", "--verbose",
                  action    = "store_true",
                  dest      = "verbose",
                  default   = False,
                  help      = "Show the full detail of git status"
                  )

parser.add_option("-r", "--remote",
                action      = "store",
                dest        = "remote",
                default     = "",
                help        = "Set the remote name (remotename:branchname)"
                )

parser.add_option("--push",
                action      = "store_true",
                dest        = "push",
                default     = False,
                help        = "Do a 'git push' if you've set a remote with -r it will push to there"
                )

parser.add_option("-p", "--pull",
                action      = "store_true",
                dest        = "pull",
                default     = False,
                help        = "Do a 'git pull' if you've set a remote with -r it will pull from there"
                )
parser.add_option("--run",
                  action="store",
                  dest="run",
                  default=None,
                  help="Run this command afterwards in every repo"
                  )

# Now, parse the args
(options, args) = parser.parse_args()

#-------------------
def show_error(error="Undefined Error!"):
#-------------------
    """Writes an error to stderr"""
    sys.stderr.write(error)
    sys.exit(1)


#-------------------
# Now, onto the main event!
#-------------------

def process_repo(repo_dir, status_output, options):
    if status_output.find('nothing') != -1 and status_output.find('up-to-date') != -1:
        result = BColors.OKGREEN + "No Changes" + BColors.ENDC

        # Pull from the remote
        if options.pull:
            pull = commands.getoutput(
                'cd '+ repo_dir +
                '; git pull '+
                ' '.join(options.remote.split(":"))
            )
            result = result + " (Pulled) \n" + pull

        # Push to the remote
        if options.push:
            push = commands.getoutput(
                'cd '+ repo_dir +
                '; git push '+
                ' '.join(options.remote.split(":"))
            )
            result = result + " (Pushed) \n" + push

    else:
        result = BColors.FAIL + "Changes" + BColors.ENDC

    if options.run:
        runout = commands.getoutput('cd {}; {}'.format(repo_dir, options.run))
        result = result + " (Run custom command) \n" + runout
    return result

if __name__ == "__main__":
    os.system('clear')
    sys.stdout.write('-- Starting git status...\n')


    sys.stdout.write('Scanning sub directories of %s\n' %options.dirname)

    subdirs = glob.glob(os.path.join(options.dirname, '*')) + glob.glob(os.path.join(options.dirname, '@*', '*'))

    # See whats here
    for repo_dir in subdirs:

        #is there a .git file
        if os.path.exists( os.path.join(repo_dir, ".git") ):

            #Yay, we found one!
            gitted = True

            # OK, contains a .git file. Let's descend into it
            # and ask git for a status
            status_output = commands.getoutput('cd '+ repo_dir + '; git status -b')

            j = status_output.find('On branch')
            k = status_output.find('\n', j)
            branch = status_output[j+10:k]
            branchColor = BColors.WARNING

            if branch == 'master':
                branchColor = BColors.OKGREEN

            branch = "[ " + branchColor + branch.ljust(15) + BColors.ENDC + " ]"

            result = process_repo(repo_dir, status_output, options)

            if not options.verbose:
                sys.stdout.write("--" + BColors.OKBLUE + repo_dir.ljust(55) + BColors.ENDC + branch + " : " + result +"\n")
            else:
                # Print including whole status output
                sys.stdout.write("\n--" + BColors.OKBLUE + repo_dir.ljust(55) + BColors.ENDC + branch + " : " + result + "\n" + status_output +"\n")

            # Come status_output of the dir and into the next
            commands.getoutput('cd ../')



    if not gitted:
        show_error("Error: None of those sub directories had a .git file.\n")

    sys.stdout.write("Done\n")
